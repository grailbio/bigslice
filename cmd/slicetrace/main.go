// Copyright 2020 GRAIL, Inc. All rights reserved.
// Use of this source code is governed by the Apache 2.0
// license that can be found in the LICENSE file.

package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"text/tabwriter"
	"time"

	"github.com/grailbio/bigslice/internal/trace"
)

func main() {
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, `usage: slicetrace <trace-file>

slicetrace prints out summary diagnostics read from trace-file, a Chrome trace
event format file generated by a bigslice program.

It shows the following reports for each invocation:

  summary
    A summary of the invocation, i.e. call location and arguments.

  slice
    The (pipelined) slice operations that compose the invocation. The table has
    the following columns:
      op
        The name slice operation.
      shards
        The number of shards used to compute the slice.
      start
        The start time of the operation, given as the offset in time from the
        start of the job.
      duration
        The duration of the operation, measured as the span between the start
        time of the first task and the end time of the last task of the tasks
        composing the operation.

  task:io
    A breakdown of task computation duration. The table has the following
    columns:
      op
        The name slice operation.
      total
        The sum of the durations of total running time of the tasks composing
        the slice.
      read
        The sum of the durations of time spent reading and decoding dependee
        task data of the tasks composing the slice. This includes data transfer
        time for data pulled from other workers.
      write
        The sum of the durations of time spent encoding and writing task output
        to disk of the tasks composing the slice.

  task:quartile
    A distribution of task durations. The table has the following columns:
      op
        The name slice operation.
      min
        The minimum duration of a task composing the slice.
      q1
        The first quartile duration of a task composing the slice.
      q2
        The median duration of a task composing the slice.
      q3
        The third quartile duration of a task composing the slice.
      max
        The maximum duration of a task composing the slice.

`)
		flag.PrintDefaults()
		os.Exit(2)
	}
	flag.Parse()
	if flag.NArg() == 0 {
		flag.Usage()
	}

	path := flag.Arg(0)
	f, err := os.Open(path)
	if err != nil {
		log.Fatalf("opening trace file: %v", err)
	}
	defer f.Close()

	t := trace.T{}
	if err := t.Decode(f); err != nil {
		log.Fatalf("decoding %q: %v", path, err)
	}
	sess := newSession(t.Events)
	for _, inv := range sess.Invs() {
		printInvSummary(inv)
		printInvSlice(sess, inv)
		printInvTaskIO(sess, inv)
		printInvTaskQuartiles(sess, inv)
	}
}

func printInvSummary(inv invocation) {
	fmt.Printf("# inv%d:summary\n", inv.index)
	w := makeTabWriter()
	fmt.Fprintf(w, "location\t%s\t\n", inv.location)
	fmt.Fprintf(w, "args\t%s\t\n", inv.args)
	w.Flush()
	fmt.Println("")
}

func printInvSlice(sess *session, inv invocation) {
	fmt.Printf("# inv%d:slice\n", inv.index)
	w := makeTabWriter()
	fmt.Fprintf(w, "op\tshards\tstart\tduration\t\n")
	for _, stats := range sess.OpStats(inv.index) {
		fmt.Fprintf(w, "%s\t%d\t%s\t%s\t\n",
			stats.op,
			stats.shards,
			formatDuration(stats.start),
			formatDuration(stats.duration))
	}
	w.Flush()
	fmt.Println("")
}

func printInvTaskIO(sess *session, inv invocation) {
	fmt.Printf("# inv%d:task:io\n", inv.index)
	w := makeTabWriter()
	fmt.Fprintf(w, "op\ttotal\tread\twrite\t\n")
	for _, stats := range sess.OpStats(inv.index) {
		fmt.Fprintf(w, "%s\t%s\t%s\t%s\t\n",
			stats.op,
			formatDuration(stats.total),
			formatDuration(stats.read),
			formatDuration(stats.write))
	}
	w.Flush()
	fmt.Println("")
}

func printInvTaskQuartiles(sess *session, inv invocation) {
	fmt.Printf("# inv%d:task:quartile\n", inv.index)
	w := makeTabWriter()
	fmt.Fprintf(w, "op\tmin\tq1\tq2\tq3\tmax\t\n")
	for _, stats := range sess.OpStats(inv.index) {
		fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%s\t%s\t\n",
			stats.op,
			formatDuration(stats.min),
			formatDuration(stats.q1),
			formatDuration(stats.q2),
			formatDuration(stats.q3),
			formatDuration(stats.max))
	}
	w.Flush()
	fmt.Println("")
}

func makeTabWriter() *tabwriter.Writer {
	return tabwriter.NewWriter(os.Stdout, 0, 0, 4, ' ', tabwriter.AlignRight)
}

func formatDuration(d time.Duration) string {
	totalSeconds := int64(d.Seconds())
	seconds := totalSeconds % 60
	minutes := (totalSeconds / 60) % 60
	hours := (totalSeconds / (60 * 60))
	return fmt.Sprintf("%02d:%02d:%02d", hours, minutes, seconds)
}
